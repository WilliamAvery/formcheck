<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>Form checker</title>
    <style>
      body {
        padding: 1em;
      }
      h1 {
        font-family: sans-serif;
      }
      input {
        width: 20em;
      }
      .action {
        color: blue;
        font-size: 80%;
      }
      .smalltext { 
        font-size: 80%;
      }
      .throbber {
	      position: absolute;
	      color: DimGray;
      }
      .throbber + p {
	      opacity: 0;
      }
      .throbberimage {
	      background-image:  url('https://upload.wikimedia.org/wikipedia/commons/thumb/7/7a/Ajax_loader_metal_512.gif/220px-Ajax_loader_metal_512.gif');  
	      background-position: 0px; 
	      background-repeat:no-repeat; 
	      background-size: contain;
      }
    </style>
    <style id="hidesuccesses"></style>
  </head>
  <body>
    <h1>Form checker</h1>
    <p>
      <a href="https://github.com/vrandezo/formcheck">Instructions</a>
    </p>
    <p id="lexemestotal">&nbsp;</p>
    <p>
      Language <br>
      <input list="languages" id="language-select" onchange="fillpos()" autofocus>
    </p>
    <p id="lexemesinlanguage"></p>
    <p id="pos-choice" hidden>
      Part of speech <br>
      <input list="pos" id="pos-select" onchange="fillfeatures()">
    </p>
    <p id="lexemesinpos">&nbsp;</p>
    <p id="conditions-choice" hidden>
      Conditions <br>
      <span onclick="addcondition()" class="action">add condition</span>
    </p>
    <p id="input-choice" hidden>
      Input form <br>
      <span id="input-forms">
        <input list="forms"> <br>
      </span>
      <span onclick="addfeature('input-forms')" class="action" id="addfeature" hide>add feature</span><span class="smalltext"> Leave blank to use lemma</span>
    </p>
    <p id="output-choice" hidden>
      Output form <br>
      <span id="output-forms">
        <input list="forms"> <br>
      </span>
      <span onclick="addfeature('output-forms')" class="action" id="addfeature" hide>add feature</span> <span class="smalltext">or press Return to continue</span>
    </p>
    <p id="formcount">&nbsp;</p>
    <p id="lemma-filter-input" hidden>
      Input filter (default operator =)<br>
      <input id="lemma-filter-text">
    </p>
    <p id="limit-choice" hidden>
      How many forms to check (limit)<br>
      <input type="number" id="limit-select" value="100">
    </p>
    <p id="offset-choice" hidden>
      At which one to start (offset)<br>
      <input type="number" id="offset-select" value="0">
    </p>
    <p id="function-choice" hidden>
      Function <br>
      <input list="functions" id="function-select" value="Z801 Echo">
    </p>
    <p id="button-choice" hidden>
      <input type="button" onclick="startcheck()" value="Check">
    </p>
    <p id="button-filter" hidden>
      <input id="button-filter-input" type="button" onclick="filterresults()" value="Hide Successes">
    </p>
    <p id="statistics"></p>
    <table id="output" hidden>
      <tr><th>Lexeme</th><th>Lemma</th><th>Input</th></th><th>Recorded</th><th>Function</th><th>OK</th></tr>
    </table>
  </body>
  <datalist id="languages"></datalist>
  <datalist id="pos"> </datalist>
  <datalist id="forms"></datalist>
  <datalist id="functions">
    <option value="Z801 Echo">
    <option value="Z10187 upper">
    <option value="Z10056 remove whitespace">
    <option value="Z10026 say twice">
    <option value="Z10072 To uppercase">
    <option value="Z10210 Add s to end">
    <option value="Z10238 replace y at end with ies">
    <option value="Z10242 replace ий at end with а">
  </datalist>
  <script>
const queryendpoint = `https://query.wikidata.org/sparql?format=json&query=`

function filterresults() {
  if (document.getElementById('hidesuccesses').innerHTML) {
    document.getElementById('hidesuccesses').innerHTML = ""
    document.getElementById('button-filter-input').value="Hide Successes"
  }
  else {
    document.getElementById('hidesuccesses').innerHTML=".success {display:none;}"
    document.getElementById('button-filter-input').value="Show Successes"
  }
}

var throbdiv
var throbtextelement
function throbelement(elementid, throbtext) {
  if (throbdiv) unthrob()
  const targetelement = document.getElementById(elementid)
  throbdiv = document.createElement('div')
  throbdiv.className='throbber'
  targetelement.parentNode.insertBefore(throbdiv, targetelement);
  const imageelement = document.createElement('span')
  imageelement.innerHTML = '&nbsp;&nbsp;&nbsp;'
  imageelement.className = 'throbberimage'
  throbdiv.insertBefore(imageelement, null);
  throbtextelement=document.createElement('span')
  throbtextelement.className = 'throbbertext'
  throbberprogress(throbtext)
  throbdiv.insertBefore(throbtextelement, null);
}

function throbberprogress(throbtext) {
	throbtextelement.innerHTML = throbtext
}

function unthrob() {
	throbdiv.remove()
	throbdiv=null
}

async function countlexemes() {
  throbberprogress('Counting lexemes...')
  const query = `
  select (count(?lexemeId) as ?count) {
    ?lexemeId a ontolex:LexicalEntry .
  }
  `
  const sparql = queryendpoint + (encodeURI(query).replace(/#/g, '%23'))
  const response = await fetch(sparql)
  const answer = await response.json()
  const count = answer.results.bindings[0].count.value
  document.getElementById('lexemestotal').innerHTML = `There are ${count} lexemes in total.`
  unthrob()
}

async function filllanguage() {
  throbelement('lexemestotal', 'Retrieving languages...')
  const query = `
  SELECT ?language ?languageLabel WHERE {
    { select distinct ?language {
      ?lexemeId dct:language ?language .
    } }
    SERVICE wikibase:label { bd:serviceParam wikibase:language "[AUTO_LANGUAGE],en". }
  } ORDER BY ?languageLabel
  `
  const sparql = queryendpoint + (encodeURI(query).replace(/#/g, '%23'))
  const response = await fetch(sparql)
  const answer = await response.json()
  languages = document.getElementById('languages')
  for (const result of answer.results.bindings) {
    var option = document.createElement('option');
    option.value = result.language.value.split('y/')[1] + ' ' +
      result.languageLabel.value;
    languages.appendChild(option);
  }
  countlexemes()
}

filllanguage()

async function countlexemesinlanguage(languageId) {
  throbelement('lexemesinlanguage', 'Counting lexemes...')
  const query = `
  select (count(?lexemeId) as ?count) {
    ?lexemeId a ontolex:LexicalEntry .
    ?lexemeId dct:language wd:${languageId} .
  }
  `
  const sparql = queryendpoint + (encodeURI(query).replace(/#/g, '%23'))
  const response = await fetch(sparql)
  const answer = await response.json()
  const count = answer.results.bindings[0].count.value
  document.getElementById('lexemesinlanguage').innerHTML = `${count} lexemes`
}

async function fillpos() {
  const languageId = document.getElementById('language-select').value.split(' ')[0]
  await countlexemesinlanguage(languageId)
  document.getElementById('pos-choice').hidden = false
  throbelement('pos-choice', 'Retrieving parts of speech...')
  const query = `
  SELECT ?pos ?posLabel WHERE {
    { select distinct ?pos where {
      ?lexemeId dct:language wd:${languageId} .
      ?lexemeId wikibase:lexicalCategory ?pos .
    } }
    SERVICE wikibase:label { bd:serviceParam wikibase:language "[AUTO_LANGUAGE],en". }
  } order by ?posLabel
  `
  const sparql = queryendpoint + (encodeURI(query).replace(/#/g, '%23'))
  const response = await fetch(sparql)
  const answer = await response.json()
  poses = document.getElementById('pos')
  while (poses.firstChild) poses.removeChild(poses.firstChild)
  for (const result of answer.results.bindings) {
    var option = document.createElement('option');
    option.value = result.pos.value.split('y/')[1] + ' ' +
      result.posLabel.value;
    poses.appendChild(option);
  }
  unthrob()
  document.getElementById('pos-select').focus()
}

async function countlexemesinpos(languageId, posId) {
  throbelement('lexemesinpos', 'Counting lexemes...')
  const query = `
  select (count(?lexemeId) as ?count) {
    ?lexemeId a ontolex:LexicalEntry .
    ?lexemeId dct:language wd:${languageId} .
    ?lexemeId wikibase:lexicalCategory wd:${posId} .
  }
  `
  const sparql = queryendpoint + (encodeURI(query).replace(/#/g, '%23'))
  const response = await fetch(sparql)
  const answer = await response.json()
  const count = answer.results.bindings[0].count.value
  document.getElementById('lexemesinpos').innerHTML = `${count} lexemes`
  unthrob()
}

async function fillfeatures() {
  const languageId = document.getElementById('language-select').value.split(' ')[0]
  const posId = document.getElementById('pos-select').value.split(' ')[0]
  await countlexemesinpos(languageId, posId)
  document.getElementById('output-choice').hidden = false
  throbelement('output-choice', 'Fetching output choices...')
  const query = `
  select ?feature ?featureLabel { {
    select distinct ?feature where {
      ?lexemeId dct:language wd:${languageId} .
      ?lexemeId wikibase:lexicalCategory wd:${posId} .
      ?lexemeId ontolex:lexicalForm ?form .
      ?form wikibase:grammaticalFeature ?feature .
    } }
    SERVICE wikibase:label { bd:serviceParam wikibase:language "[AUTO_LANGUAGE],en". }
    } order by ?featureLabel
  `
  const sparql = queryendpoint + (encodeURI(query).replace(/#/g, '%23'))
  const response = await fetch(sparql)
  const answer = await response.json()
  forms = document.getElementById('forms')
  while (forms.firstChild) forms.removeChild(forms.firstChild)
  for (const result of answer.results.bindings) {
    var option = document.createElement('option');
    option.value = result.feature.value.split('y/')[1] + ' ' +
      result.featureLabel.value;
    forms.appendChild(option);
  }
  // TODO document.getElementById('conditions-choice').hidden = false
  document.getElementById('input-choice').hidden = false
  document.getElementById('output-forms').children[0].focus()
  unthrob()
}

document.getElementById("output-forms").addEventListener('keydown', event => {
    selectedfeature(event.key)
});

function getfeatures(elementid) {
  var features=[]
  for (const outselect of document.getElementById(elementid).querySelectorAll('input')) {
    let val = outselect.value.split(' ')[0]
    if (val) {
      features.push(val)
    }
  }
  return features
}

async function selectedfeature(outputselectkey) {
  if (outputselectkey !== 'Enter')
    return
  const languageId = document.getElementById('language-select').value.split(' ')[0]
  const posId = document.getElementById('pos-select').value.split(' ')[0]
  const inputfeatures = getfeatures('input-forms')
  const features = getfeatures('output-forms')
  var query = `
  ask {
    ?lexemeId dct:language wd:${languageId} .
    ?lexemeId wikibase:lexicalCategory wd:${posId} .
    ?lexemeId ontolex:lexicalForm ?form .
    `
    for (const feature of features) {
    query += `?form wikibase:grammaticalFeature wd:${feature} . 
    `
  }
  if (inputfeatures) {
    query += 
    `?lexemeId ontolex:lexicalForm ?inform .
    `
    for (const feature of inputfeatures) {
      query += `?inform wikibase:grammaticalFeature wd:${feature} . 
      `
    }
    query += `
      filter not exists {
        ?inform wikibase:grammaticalFeature ?unwanted.
        filter(?unwanted not in (wd:${inputfeatures.join(',wd:')}) )
      }`
    }
  query += `
    filter not exists {
      ?form wikibase:grammaticalFeature ?unwanted.
      filter(?unwanted not in (wd:${features.join(',wd:')}) )
    }
  }
  `
  const sparql = queryendpoint + (encodeURI(query).replace(/#/g, '%23'))
  const response = await fetch(sparql)
  const answer = await response.json()
  if (answer.boolean) {
    getready(languageId, posId, inputfeatures, features)
  } 
}

async function addfeature(parent) {
  const br = document.createElement("br")
  const input = document.createElement("input")
  input.setAttribute("list", "forms")
  document.getElementById(parent).append(input, br)
  input.focus()
}

async function countforms(languageId, posId, inputfeatures, features) {
  throbelement('formcount', 'Counting forms...')
  var query = `
  SELECT (COUNT(?featurecount) as ?count) WHERE {`
    if (inputfeatures.length) {
      query += `{
      SELECT ?lexemeId ?inform (COUNT(?inform) as ?infeaturecount)
      { 
      ?lexemeId dct:language wd:${languageId} .
      ?lexemeId wikibase:lexicalCategory wd:${posId} .
      ?lexemeId ontolex:lexicalForm ?inform .
      `
      for (const feature of inputfeatures) {
        query += `?inform wikibase:grammaticalFeature wd:${feature} . 
        `
      }
      query += `
      ?inform wikibase:grammaticalFeature ?inunwanted. 
    }
            GROUP BY ?lexemeId ?inform
            HAVING (?infeaturecount=${inputfeatures.length})
          }`
    }
    query += `{
    SELECT ?lexemeId ?form (COUNT(?form) as ?featurecount)
    { 
    ?lexemeId dct:language wd:${languageId} .
    ?lexemeId wikibase:lexicalCategory wd:${posId} .
    ?lexemeId ontolex:lexicalForm ?form .`
  for (const feature of features) {
    query += `?form wikibase:grammaticalFeature wd:${feature} . 
    `
  }
  query += `
  ?form wikibase:grammaticalFeature ?unwanted. 
  } GROUP by ?lexemeId ?form
  HAVING (?featurecount = ${features.length})
  }
}
  `
  const sparql = queryendpoint + (encodeURI(query).replace(/#/g, '%23'))
  const response = await fetch(sparql)
  const answer = await response.json()
  const count = answer.results.bindings[0].count.value
  document.getElementById('formcount').innerHTML = `${count} forms`
  unthrob()
}

async function getready(languageId, posId, inputfeatures, features) {
  document.getElementById('addfeature').hidden = false
  await countforms(languageId, posId, inputfeatures, features)
  document.getElementById('lemma-filter-input').hidden = false
  document.getElementById('limit-choice').hidden = false
  document.getElementById('offset-choice').hidden = false
  document.getElementById('function-choice').hidden = false
  document.getElementById('button-choice').hidden = false
  document.getElementById('function-select').focus()
}

async function startcheck() {
  throbelement('button-choice', 'Fetching representations...')
  const languageId = document.getElementById('language-select').value.split(' ')[0]
  const posId = document.getElementById('pos-select').value.split(' ')[0]
  const functionId = document.getElementById('function-select').value.split(' ')[0]
  const limit = document.getElementById('limit-select').value
  const offset = document.getElementById('offset-select').value
  const inputfeatures = getfeatures('input-forms')
  const features = getfeatures('output-forms')

  const filterinput = document.getElementById('lemma-filter-text').value
  var filtertext = ""
  if (filterinput) {
      let target = inputfeatures.length ? 'input' : 'lemma'
      filtertext += `
      FILTER (`
      if (filterinput[0] == '\\') {
        filtertext += filterinput.substring(1)
      } else if (filterinput[0] == '/' && filterinput.lastIndexOf('/')){
        filtertext += `REGEX(str(?${target}), '${filterinput.slice(1, filterinput.lastIndexOf('/'))}', '${filterinput.slice(filterinput.lastIndexOf('/') + 1)}') `
      } else if (filterinput[0] == '-' && filterinput.slice(-1) == '-'){
        filtertext += `CONTAINS(str(?${target}), '${filterinput.slice(1, -1)}') `
      } else if (filterinput.slice(-1) == '-'){
        filtertext += `STRSTARTS(str(?${target}), '${filterinput.slice(0, -1)}') `
      } else if (filterinput[0] == '-'){
        filtertext += `STRENDS(str(?${target}), '${filterinput.substring(1)}') `
      } else {
        let op = "="
        let val = filterinput
        for (initop of [">=", "<=", "=", ">", "<"]){
          if (filterinput.startsWith(initop)) {
            op = initop
            val = filterinput.substring(op.length).trim()
            break
          }
        }
        filtertext += `str(?${target}) ${op} '${val}'`
      }
      filtertext += ")"
  }
  var query = `
    SELECT ?lexemeId ?form ?lemma ?representation ?featurecount ?inform ?input WHERE {
      { SELECT  ?lexemeId ?form ?lemma ?representation (COUNT(?form) as ?featurecount){
      ?lexemeId dct:language wd:${languageId} .
      ?lexemeId wikibase:lemma ?lemma .
      ?lexemeId wikibase:lexicalCategory wd:${posId} .
      ?lexemeId ontolex:lexicalForm ?form .
      ?form wikibase:grammaticalFeature ?unwanted. 
  `
  for (feature of features) {
    query += `?form wikibase:grammaticalFeature wd:${feature} . `
  }
  query += `
      ?form ontolex:representation ?representation .
 `
  if (!inputfeatures.length && filtertext)
    query += filtertext

  query += `
  }  GROUP by ?lexemeId ?form ?lemma ?representation 
    HAVING (?featurecount = ${features.length})
}`
if (inputfeatures.length) {
  query += `
{SELECT  ?lexemeId ?inform ?input (COUNT(?inform) as ?infeaturecount){
      ?lexemeId dct:language wd:${languageId} .
      ?lexemeId wikibase:lexicalCategory wd:${posId} .
      ?lexemeId ontolex:lexicalForm ?inform .
      ?inform wikibase:grammaticalFeature ?inunwanted. 
  `
  for (feature of inputfeatures) {
    query += `?inform wikibase:grammaticalFeature wd:${feature} . `
  }
  query += `
      ?inform ontolex:representation ?input .`     
  if (filtertext)
    query += filtertext
  query += `
  }  GROUP by ?lexemeId ?inform ?input 
    HAVING (?infeaturecount = ${inputfeatures.length})
}`
}
query += `
}
  order by ?lemma limit ${limit} offset ${offset}`
  const sparql = queryendpoint + (encodeURI(query).replace(/#/g, '%23'))
  const answer = await (await fetch(sparql)).json()
  var successes = 0
  var fails = 0
  document.getElementById('statistics').innerHTML = `${successes} successes, ${fails} fails (100.00%)`
  document.getElementById('button-filter').hidden = false
  document.getElementById('output').hidden = false
  for (const line of answer.results.bindings) {
	  throbberprogress(`Checking representation ${successes + fails + 1} of ${answer.results.bindings.length}`)
    const row = document.getElementById("output").insertRow(1)
    row.insertCell().innerHTML = `<a href="${line.lexemeId.value}">${line.lexemeId.value.split('y/')[1]}</a>`
    row.insertCell().innerHTML = line.lemma.value
    row.insertCell().innerHTML = inputfeatures.length ? line.input.value : line.lemma.value
    row.insertCell().innerHTML = line.representation.value
    singular = inputfeatures.length ? line.input.value : line.lemma.value
    const wikifunction = `https://wikifunctions.beta.wmflabs.org/w/api.php?` +
      `action=wikilambda_function_call&format=json&wikilambda_function_call_zobject=` +
      `%7B%20%22Z1K1%22%3A%20%22Z7%22%2C%20%22Z7K1%22%3A%20%22${functionId}%22%2C%20%22` +
      `${functionId}K1%22%3A%20%22${singular}%22%20%7D&formatversion=2&origin=*`
    const headers = {
      'Content-Type': 'application/json',
      'origin': '*'
    }
    const res = await fetch(wikifunction, { headers })
    const result = await res.json()
    const text = result.query.wikilambda_function_call.data
    const jsonnn = JSON.parse(text)
    row.insertCell().innerHTML = jsonnn.Z22K1
    if (jsonnn.Z22K1 == line.representation.value) {
      row.insertCell().innerHTML += `✅ `
      row.className='success'
      successes += 1
    } else {
      row.insertCell().innerHTML += `❌`
      row.className='failure'
      fails += 1
    }
    document.getElementById('statistics').innerHTML = `${successes} successes, ${fails} fails (${(100.0*successes/(successes+fails)).toFixed(2)}%)`
  }
  unthrob()
}
  </script>
</html>
